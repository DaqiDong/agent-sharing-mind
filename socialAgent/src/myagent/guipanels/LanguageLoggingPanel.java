/*
A language module which expresses the agent's inside mind activities using human readable language

Author: Daqi Dong
Date: 12/30/2019 --> 1/xx/2020

TODO:
- currently we made the expression (language) process a kind of GuiPanel stuff so we may easily display the mind activities, 
while for long term we need to make it a typical module like PAM and deliver the expression results to the environment like action execution part. 
In the environment, we need to somehow create the corresponding actuators (mouth?) to execute the expression results (a sequence of words?)

 */
package myagent.guipanels;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Iterator;

import javax.swing.JPanel;

import myagent.modules.ButtonEnvironment;
import edu.memphis.ccrg.lida.framework.ModuleName;
import edu.memphis.ccrg.lida.framework.gui.panels.GuiPanel;
import edu.memphis.ccrg.lida.framework.gui.panels.GuiPanelImpl;
import edu.memphis.ccrg.lida.framework.shared.Node;
import edu.memphis.ccrg.lida.framework.shared.NodeStructure;
import edu.memphis.ccrg.lida.globalworkspace.BroadcastContent;
import edu.memphis.ccrg.lida.globalworkspace.BroadcastListener;

import edu.memphis.ccrg.lida.framework.tasks.TaskManager;
import edu.memphis.ccrg.lida.globalworkspace.Coalition;
import edu.memphis.ccrg.lida.globalworkspace.GlobalWorkspace;
import edu.memphis.ccrg.lida.globalworkspace.triggers.BroadcastTrigger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Random;
import javax.swing.JScrollBar;

/**
 *
 * @author Daqi
 * 
 */
public class LanguageLoggingPanel extends GuiPanelImpl implements
		BroadcastListener {
    
    private static final Logger logger = Logger
			.getLogger(LanguageLoggingPanel.class.getCanonicalName());
    
    private GlobalWorkspace GWmodule;
    
    //TODO: Saving the couple recent broadcast content first and map-->display them later together
    private LinkedList<BroadcastDetail> recentBbroadcasts = new LinkedList<BroadcastDetail>();
    private int recentBroadcastsSize;
    private final static int DEFAULT_RECENT_BROADCAST_SIZE = 20;

    /**
     * Creates new form LanguageLoggingPanel
     */
    public LanguageLoggingPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        LanguageText = new javax.swing.JTextArea();

        LanguageText.setColumns(20);
        LanguageText.setRows(5);
        jScrollPane1.setViewportView(LanguageText);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextArea LanguageText;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables

    @Override
    public void initPanel(String[] param) {
        GWmodule = (GlobalWorkspace) agent
                        .getSubmodule(ModuleName.GlobalWorkspace);
        if (GWmodule == null) {
                logger
                                .log(
                                                Level.WARNING,
                                                "Error initializing NodeStructure Panel, Module does not exist in agent.",
                                                0L);
                return;
        }
        GWmodule.addListener(this);

        recentBroadcastsSize = DEFAULT_RECENT_BROADCAST_SIZE;

        if (param.length > 0) {
                try {
                        recentBroadcastsSize = Integer.parseInt(param[0]);
                } catch (NumberFormatException e) {
                        logger.log(Level.WARNING,
                                        "parse error, using default recent broadcast size");
                }
        } else {
                logger.log(Level.INFO, "using default recent broadcast size");
        }
    }
    
    @Override
    public void refresh() {
        
    }
    
    private String mapping(NodeStructure content){
        

        String words = "";
        
        String dataWords = "";
        
        //TODO: give each module its own words; currently we just build in the words for GW
        ArrayList<String> GWFeatures = new ArrayList<String>();
        
        GWFeatures.add("I am aware of ");
        GWFeatures.add("I will respond to ");
        
        Random rand = new Random();
        
        String structureWords = GWFeatures.get(rand.nextInt(GWFeatures.size()));
        
        Collection<Node> nodes = content.getNodes();
        
        //TODO: we assume there are nodes only so not dealing with links;
        //addtionally dealing with links next
        
        //building the data words
        Iterator<Node> iterator = nodes.iterator(); 
                
        if (iterator.hasNext()){//having the first node
            
            dataWords = iterator.next().getLabel();
            
            if (iterator.hasNext()){//having the following node(s)
                
                String andWord = " and ";
                
                if (nodes.size() > 2)
                    andWord = ", and ";
                
                while(true){
                    String word = iterator.next().getLabel();
                    
                    if (!iterator.hasNext()){//the current word is the last one
                        dataWords += andWord + word;
                        break;
                        
                    }else{
                        dataWords += ", ";
                    }
                }
            }
        }
            
        if (dataWords != ""){
            
            
            words =  structureWords + "a "+ dataWords + " object.";
        }else{
            words =  structureWords + "nothing.";
        }
             
        return words;
    }
    
    
    @Override
    public void display(Object o) {
        
        NodeStructure mindContent = (NodeStructure)o;
        
        //TODO: mapping the mind content (activities) to the human readable words
        //LanguageText.append(mindContent.toString()+"\n");
        
        String words = mapping(mindContent);
        
        LanguageText.append("The agent: " + words + "\n");
        
        JScrollBar jsb = jScrollPane1.getVerticalScrollBar();
        jsb.setValue(jsb.getMaximum());
    }
    
    @Override
    public void learn(BroadcastContent bc) {
        // No learning in panel
    }
    
    @Override
    public void receiveBroadcast(BroadcastContent bc) {
    //TODO:this interface, using BroadcastContent, is for the older Framework 1.1b, while the newer version use Coalition
        BroadcastDetail bd = new BroadcastDetail((NodeStructure) bc, (Double) GWmodule.getModuleContent("winnerCoalActivation"),
                (BroadcastTrigger) GWmodule.getModuleContent("lastBroadcastTrigger"), TaskManager.getCurrentTick(),
                GWmodule.getBroadcastSentCount());
        synchronized (this) {
            display(bd.getBroadcastContent());

        }
    }
    
	private class BroadcastDetail {

		private final NodeStructure broadcastContent;
		private final double winnerCoalActivation;
		private final BroadcastTrigger lastBroadcastTrigger;
		private final long tickAtBroadcast;
		private final long broadcastSentCount;

		public BroadcastDetail(NodeStructure broadcastContent,
				double winnerCoalActivation,
				BroadcastTrigger lastBroadcastTrigger, long tickAtBroadcast,
				long broadcastSentCount) {
			this.broadcastContent = broadcastContent;
			this.winnerCoalActivation = winnerCoalActivation;
			this.lastBroadcastTrigger = lastBroadcastTrigger;
			this.tickAtBroadcast = tickAtBroadcast;
			this.broadcastSentCount = broadcastSentCount;
		}

		/**
		 * @return the broadcastContent
		 */
		public NodeStructure getBroadcastContent() {
			return broadcastContent;
		}

		/**
		 * @return the winnerCoalActivation
		 */
		public double getWinnerCoalActivation() {
			return winnerCoalActivation;
		}

		/**
		 * @return the lastBroadcastTrigger
		 */
		public BroadcastTrigger getLastBroadcastTrigger() {
			return lastBroadcastTrigger;
		}

		/**
		 * @return the tickAtBroadcast
		 */
		public long getTickAtBroadcast() {
			return tickAtBroadcast;
		}

		/**
		 * @return the broadcastSentCount
		 */
		public long getBroadcastSentCount() {
			return broadcastSentCount;
		}
	}


}
